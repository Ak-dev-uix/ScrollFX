/*!
 *  ScrollFX.js v1.0.0
 *  Cinematic Scroll-Controlled Frame Animation Framework
 *  -----------------------------------------------------
 *  Author   : Ak.Dev
 *  Website  : https://ak-folio.netlify.app
 *  GitHub   : https://github.com/Ak-dev-uix/ScrollFX
 *  License  : MIT
 *  Created  : November 2025
 *  Powered  : GSAP + ScrollTrigger
 *
 *  Description:
 *  ScrollFX lets you create ultra-smooth, cinematic frame-by-frame
 *  scroll animations with just a few HTML data attributes.
 *  Lightweight. Responsive. Developer Friendly.
 *
 *  Â© 2025 Ak.Dev | All rights reserved.
 */

gsap.registerPlugin(ScrollTrigger);

(() => {

  // ===== Helper Functions =====
  const pad = (n, len) => String(n).padStart(len, "0");

  // ===== Initialize ScrollFX Sections =====
  document.querySelectorAll("[data-scrollfx]").forEach((section, index) => {

    const canvas = section.querySelector("canvas");
    if (!canvas) return;

    // ----- Section Identification -----
    const sectionId = section.dataset.section || (index + 1).toString();
    console.log("ScrollFX initialized for Section:", sectionId);

    // ----- Dataset Configuration -----
    const ctx = canvas.getContext("2d");
    const folder = section.dataset.folder || "";
    const name = section.dataset.name || "frame-";
    const frames = parseInt(section.dataset.frames) || 0;
    const ext = section.dataset.ext || "jpg";
    const len = parseInt(section.dataset.length) || 3;
    const bg = section.dataset.bg || "";

    if (!folder || !frames) {
      console.warn("ScrollFX: Missing folder or frame count in Section:", sectionId);
      return;
    }

    let images = new Array(frames);
    let currentFrame = 0;
    let firstLoaded = false;

    // ===== Draw Background Fallback =====
    const drawBackground = () => {
      if (!bg) return;
      const bgImg = new Image();
      bgImg.src = bg;
      bgImg.onload = () => ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
      bgImg.onerror = () => {
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, "#000");
        gradient.addColorStop(1, "#111");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      };
    };

    // ===== Draw Animation Frame =====
    const drawFrame = (i) => {
      const img = images[i];
      if (!img || !img.complete) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    };

    // ===== Handle Resize =====
    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (firstLoaded) drawFrame(currentFrame);
      else drawBackground();
    };
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // ===== Lazy Image Loader =====
    const loadImage = (i) => {
      if (images[i]) return;
      const img = new Image();
      img.src = `${folder}/${name}${pad(i + 1, len)}.${ext}`;
      img.onload = () => {
        if (!firstLoaded) {
          firstLoaded = true;
          drawFrame(0);
        }
      };
      images[i] = img;
    };

    // ----- Preload First Frames -----
    loadImage(0);
    loadImage(1);

    // ===== Scroll Animation (GSAP + ScrollTrigger) =====
    const animObj = { frame: 0 };
    gsap.to(animObj, {
      frame: frames - 1,
      snap: "frame",
      ease: "none",
      scrollTrigger: {
        id: `scrollfx-section-${sectionId}`,
        trigger: section,
        start: "top top",
        end: "+=" + (frames * 1.5) + "px",
        scrub: 1,
        pin: true,
        anticipatePin: 1,
        invalidateOnRefresh: true,
      
        onEnter: () => {      
          canvas.style.opacity = 1;
        },
        onLeave: () => {
          drawFrame(frames - 1);
          section.style.background = `url(${folder}/${name}${pad(frames, len)}.${ext}) center/cover no-repeat`; 
          canvas.style.opacity = 0;
        },
        onEnterBack: () => {
          canvas.style.opacity = 1;
        },
        onLeaveBack: () => {
          drawFrame(0);
        }
      },

      onUpdate: () => {
        const i = Math.floor(animObj.frame);
        currentFrame = i;
        loadImage(i);
        loadImage(i + 1);
        drawFrame(i);
      }
    });
  });

})();
